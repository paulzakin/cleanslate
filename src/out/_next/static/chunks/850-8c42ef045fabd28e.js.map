{"version":3,"file":"static/chunks/850-8c42ef045fabd28e.js","mappings":"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","sources":["webpack://_N_E/../node_modules/.pnpm/quick-score@0.2.0/node_modules/quick-score/lib/index.esm.js","webpack://_N_E/<anon>"],"sourcesContent":["/**\n * A class representing a half-open interval of characters.  A range's `location`\n * property and `max()` value can be used as arguments for the `substring()`\n * method to extract a range of characters.\n */\nclass Range {\n\t/**\n\t * @memberOf Range.prototype\n\t * @member {number} location  Starting index of the range.\n\t */\n\n\t/**\n\t * @memberOf Range.prototype\n\t * @member {number} length  Number of characters in the range.\n\t */\n\n\t/**\n\t * @param {number} [location=-1]  Starting index of the range.\n\t * @param {number} [length=0]  Number of characters in the range.\n\t */\n\tconstructor(\n\t\tlocation = -1,\n\t\tlength = 0)\n\t{\n\t\tthis.location = location;\n\t\tthis.length = length;\n\t}\n\n\n\t/* eslint no-inline-comments: 0 */\n\t/**\n\t * Gets the end index of the range, which indicates the character\n\t * immediately after the last one in the range.\n\t *\n\t * @returns {number}\n\t */\n\t/**\n\t * Sets the end index of the range, which indicates the character\n\t * immediately after the last one in the range.\n\t *\n\t * @param {number} [value]  End of the range.\n\t *\n\t * @returns {number}\n\t */\n\tmax(\n\t\tvalue)\n\t{\n\t\tif (typeof value == \"number\") {\n\t\t\tthis.length = value - this.location;\n\t\t}\n\n\t\t\t// the NSMaxRange() function in Objective-C returns this value\n\t\treturn this.location + this.length;\n\t}\n\n\n\t/**\n\t * Returns whether the range contains a location >= 0.\n\t *\n\t * @returns {boolean}\n\t */\n\tisValid()\n\t{\n\t\treturn (this.location > -1);\n\t}\n\n\n\t/**\n\t * Returns an array of the range's start and end indexes.\n\t *\n\t * @returns {RangeTuple}\n\t */\n\ttoArray()\n\t{\n\t\treturn [this.location, this.max()];\n\t}\n\n\n\t/**\n\t * Returns a string representation of the range's open interval.\n\t *\n\t * @returns {string}\n\t */\n\ttoString()\n\t{\n\t\tif (this.location == -1) {\n\t\t\treturn \"invalid range\";\n\t\t} else {\n\t\t\treturn \"[\" + this.location + \",\" + this.max() + \")\";\n\t\t}\n\t}\n}\n\nconst BaseConfigDefaults = {\n\twordSeparators: \"-/\\\\:()<>%._=&[]+ \\t\\n\\r\",\n\tuppercaseLetters: (() => {\n\t\tconst charCodeA = \"A\".charCodeAt(0);\n\t\tconst uppercase = [];\n\n\t\tfor (let i = 0; i < 26; i++) {\n\t\t\tuppercase.push(String.fromCharCode(charCodeA + i));\n\t\t}\n\n\t\treturn uppercase.join(\"\");\n\t})(),\n\tignoredScore: 0.9,\n\tskippedScore: 0.15,\n\temptyQueryScore: 0,\n\t\t// long, nearly-matching queries can generate up to 2^queryLength loops,\n\t\t// so support worst-case queries up to 16 characters and then give up\n\t\t// and return 0 for longer queries that may or may not actually match\n\tmaxIterations: Math.pow(2, 16)\n};\nconst QSConfigDefaults = {\n\tlongStringLength: 150,\n\tmaxMatchStartPct: 0.15,\n\tminMatchDensityPct: 0.75,\n\tmaxMatchDensityPct: 0.95,\n\tbeginningOfStringPct: 0.1\n};\n\n\nclass Config {\n\tconstructor(\n\t\toptions)\n\t{\n\t\tObject.assign(this, BaseConfigDefaults, options);\n\t}\n\n\n\tuseSkipReduction()\n\t{\n\t\treturn true;\n\t}\n\n\n\tadjustRemainingScore(\n\t\tstring,\n\t\tquery,\n\t\tremainingScore,\n\t\tskippedSpecialChar,\n\t\tsearchRange,\n\t\tremainingSearchRange,\n\t\tmatchedRange,\n\t\tfullMatchedRange)\n\t{\n\t\t\t// use the original Quicksilver expression for the remainingScore\n\t\treturn remainingScore * remainingSearchRange.length;\n\t}\n}\n\n\nclass QuickScoreConfig extends Config {\n\tconstructor(\n\t\toptions)\n\t{\n\t\tsuper(Object.assign({}, QSConfigDefaults, options));\n\t}\n\n\n\tuseSkipReduction(\n\t\tstring,\n\t\tquery,\n\t\tremainingScore,\n\t\tsearchRange,\n\t\tremainingSearchRange,\n\t\tmatchedRange,\n\t\tfullMatchedRange)\n\t{\n\t\tconst len = string.length;\n\t\tconst isShortString = len <= this.longStringLength;\n\t\tconst matchStartPercentage = fullMatchedRange.location / len;\n\n\t\treturn isShortString || matchStartPercentage < this.maxMatchStartPct;\n\t}\n\n\n\tadjustRemainingScore(\n\t\tstring,\n\t\tquery,\n\t\tremainingScore,\n\t\tskippedSpecialChar,\n\t\tsearchRange,\n\t\tremainingSearchRange,\n\t\tmatchedRange,\n\t\tfullMatchedRange)\n\t{\n\t\tconst isShortString = string.length <= this.longStringLength;\n\t\tconst matchStartPercentage = fullMatchedRange.location / string.length;\n\t\tlet matchRangeDiscount = 1;\n\t\tlet matchStartDiscount = (1 - matchStartPercentage);\n\n\t\t\t// discount the remainingScore based on how much larger the match is\n\t\t\t// than the query, unless the match is in the first 10% of the\n\t\t\t// string, the match range isn't too sparse and the whole string is\n\t\t\t// not too long.  also only discount if we didn't skip any whitespace\n\t\t\t// or capitals.\n\t\tif (!skippedSpecialChar) {\n\t\t\tmatchRangeDiscount = query.length / fullMatchedRange.length;\n\t\t\tmatchRangeDiscount = (isShortString &&\n\t\t\t\tmatchStartPercentage <= this.beginningOfStringPct &&\n\t\t\t\tmatchRangeDiscount >= this.minMatchDensityPct) ?\n\t\t\t\t1 : matchRangeDiscount;\n\t\t\tmatchStartDiscount = matchRangeDiscount >= this.maxMatchDensityPct ?\n\t\t\t\t1 : matchStartDiscount;\n\t\t}\n\n\t\t\t// discount the scores of very long strings\n\t\treturn remainingScore *\n\t\t\tMath.min(remainingSearchRange.length, this.longStringLength) *\n\t\t\tmatchRangeDiscount * matchStartDiscount;\n\t}\n}\n\n\nfunction createConfig(\n\toptions)\n{\n\tif (options instanceof Config) {\n\t\t\t// this is a full-fledged Config instance, so we don't need to do\n\t\t\t// anything to it\n\t\treturn options;\n\t} else {\n\t\t\t// create a complete config from this\n\t\treturn new QuickScoreConfig(options);\n\t}\n}\n\n\nconst DefaultConfig = createConfig();\nconst BaseConfig = new Config();\nconst QuicksilverConfig = new Config({\n\t\t// the Quicksilver algorithm returns .9 for empty queries\n\temptyQueryScore: 0.9,\n\tadjustRemainingScore: function(\n\t\tstring,\n\t\tquery,\n\t\tremainingScore,\n\t\tskippedSpecialChar,\n\t\tsearchRange,\n\t\tremainingSearchRange,\n\t\tmatchedRange,\n\t\tfullMatchedRange)\n\t{\n\t\tlet score = remainingScore * remainingSearchRange.length;\n\n\t\tif (!skippedSpecialChar) {\n\t\t\t\t// the current QuickSilver algorithm reduces the score by half\n\t\t\t\t// this value when no special chars are skipped, so add the half\n\t\t\t\t// back in to match it\n\t\t\tscore += ((matchedRange.location - searchRange.location) / 2.0);\n\t\t}\n\n\t\treturn score;\n\t}\n});\n\n/**\n * Scores a string against a query.\n *\n * @param {string} string  The string to score.\n *\n * @param {string} query  The query string to score the `string` parameter against.\n *\n * @param {Array<RangeTuple>} [matches]  If supplied, `quickScore()` will push onto\n * `matches` an array with start and end indexes for each substring range of\n * `string` that matches `query`.  These indexes can be used to highlight the\n * matching characters in an auto-complete UI.\n *\n * @param {string} [transformedString]  A transformed version of the string that\n * will be used for matching.  This defaults to a lowercase version of `string`,\n * but it could also be used to match against a string with all the diacritics\n * removed, so an unaccented character in the query would match an accented one\n * in the string.\n *\n * @param {string} [transformedQuery]  A transformed version of `query`.  The\n * same transformation applied to `transformedString` should be applied to this\n * parameter, or both can be left as `undefined` for the default lowercase\n * transformation.\n *\n * @param {object} [config]  A configuration object that can modify how the\n * `quickScore` algorithm behaves.\n *\n * @param {Range} [stringRange]  The range of characters in `string` that should\n * be checked for matches against `query`.  Defaults to the entire `string`\n * parameter.\n *\n * @returns {number}  A number between 0 and 1 that represents how well the\n * `query` matches the `string`.\n */\nfunction quickScore(\n\tstring,\n\tquery,\n\tmatches,\n\ttransformedString = string.toLocaleLowerCase(),\n\ttransformedQuery = query.toLocaleLowerCase(),\n\tconfig = DefaultConfig,\n\tstringRange = new Range(0, string.length))\n{\n\tlet iterations = 0;\n\n\tif (query) {\n\t\treturn calcScore(stringRange, new Range(0, query.length), new Range());\n\t} else {\n\t\treturn config.emptyQueryScore;\n\t}\n\n\n\tfunction calcScore(\n\t\tsearchRange,\n\t\tqueryRange,\n\t\tfullMatchedRange)\n\t{\n\t\tif (!queryRange.length) {\n\t\t\t\t// deduct some points for all remaining characters\n\t\t\treturn config.ignoredScore;\n\t\t} else if (queryRange.length > searchRange.length) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst initialMatchesLength = matches && matches.length;\n\n\t\tfor (let i = queryRange.length; i > 0; i--) {\n\t\t\tif (iterations > config.maxIterations) {\n\t\t\t\t\t// a long query that matches the string except for the last\n\t\t\t\t\t// character can generate 2^queryLength iterations of this\n\t\t\t\t\t// loop before returning 0, so short-circuit that when we've\n\t\t\t\t\t// seen too many iterations (bit of an ugly kludge, but it\n\t\t\t\t\t// avoids locking up the UI if the user somehow types an\n\t\t\t\t\t// edge-case query)\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\titerations++;\n\n\t\t\tconst querySubstring = transformedQuery.substring(queryRange.location, queryRange.location + i);\n\t\t\t\t// reduce the length of the search range by the number of chars\n\t\t\t\t// we're skipping in the query, to make sure there's enough string\n\t\t\t\t// left to possibly contain the skipped chars\n\t\t\tconst matchedRange = getRangeOfSubstring(transformedString, querySubstring,\n\t\t\t\tnew Range(searchRange.location, searchRange.length - queryRange.length + i));\n\n\t\t\tif (!matchedRange.isValid()) {\n\t\t\t\t\t// we didn't find the query substring, so try again with a\n\t\t\t\t\t// shorter substring\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!fullMatchedRange.isValid()) {\n\t\t\t\tfullMatchedRange.location = matchedRange.location;\n\t\t\t} else {\n\t\t\t\tfullMatchedRange.location = Math.min(fullMatchedRange.location, matchedRange.location);\n\t\t\t}\n\n\t\t\tfullMatchedRange.max(matchedRange.max());\n\n\t\t\tif (matches) {\n\t\t\t\tmatches.push(matchedRange.toArray());\n\t\t\t}\n\n\t\t\tconst remainingSearchRange = new Range(matchedRange.max(), searchRange.max() - matchedRange.max());\n\t\t\tconst remainingQueryRange = new Range(queryRange.location + i, queryRange.length - i);\n\t\t\tconst remainingScore = calcScore(remainingSearchRange, remainingQueryRange, fullMatchedRange);\n\n\t\t\tif (remainingScore) {\n\t\t\t\tlet score = remainingSearchRange.location - searchRange.location;\n\t\t\t\t\t// default to true since we only want to apply a discount if\n\t\t\t\t\t// we hit the final else clause below, and we won't get to\n\t\t\t\t\t// any of them if the match is right at the start of the\n\t\t\t\t\t// searchRange\n\t\t\t\tlet skippedSpecialChar = true;\n\t\t\t\tconst useSkipReduction = config.useSkipReduction(string, query,\n\t\t\t\t\tremainingScore, remainingSearchRange, searchRange,\n\t\t\t\t\tremainingSearchRange, matchedRange, fullMatchedRange);\n\n\t\t\t\tif (matchedRange.location > searchRange.location) {\n\t\t\t\t\t\t// some letters were skipped when finding this match, so\n\t\t\t\t\t\t// adjust the score based on whether spaces or capital\n\t\t\t\t\t\t// letters were skipped\n\t\t\t\t\tif (useSkipReduction &&\n\t\t\t\t\t\t\tconfig.wordSeparators.indexOf(string[matchedRange.location - 1]) > -1) {\n\t\t\t\t\t\tfor (let j = matchedRange.location - 2; j >= searchRange.location; j--) {\n\t\t\t\t\t\t\tif (config.wordSeparators.indexOf(string[j]) > -1) {\n\t\t\t\t\t\t\t\tscore--;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tscore -= config.skippedScore;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (useSkipReduction &&\n\t\t\t\t\t\t\tconfig.uppercaseLetters.indexOf(string[matchedRange.location]) > -1) {\n\t\t\t\t\t\tfor (let j = matchedRange.location - 1; j >= searchRange.location; j--) {\n\t\t\t\t\t\t\tif (config.uppercaseLetters.indexOf(string[j]) > -1) {\n\t\t\t\t\t\t\t\tscore--;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tscore -= config.skippedScore;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// reduce the score by the number of chars we've\n\t\t\t\t\t\t\t// skipped since the beginning of the search range\n\t\t\t\t\t\tscore -= matchedRange.location - searchRange.location;\n\t\t\t\t\t\tskippedSpecialChar = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tscore += config.adjustRemainingScore(string,\n\t\t\t\t\tquery, remainingScore, skippedSpecialChar, searchRange,\n\t\t\t\t\tremainingSearchRange, matchedRange, fullMatchedRange);\n\t\t\t\tscore /= searchRange.length;\n\n\t\t\t\treturn score;\n\t\t\t} else if (matches) {\n\t\t\t\t\t// the remaining query does not appear in the remaining\n\t\t\t\t\t// string, so strip off any matches we've added during the\n\t\t\t\t\t// current call, as they'll be invalid when we start over\n\t\t\t\t\t// with a shorter piece of the query\n\t\t\t\tmatches.length = initialMatchesLength;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n}\n\n\t// make createConfig() available on quickScore so that the QuickScore\n\t// constructor has access to it\nquickScore.createConfig = createConfig;\n\n\nfunction getRangeOfSubstring(\n\tstring,\n\tquery,\n\tsearchRange)\n{\n\tconst index = string.indexOf(query, searchRange.location);\n\tconst result = new Range();\n\n\tif (index > -1 && index < searchRange.max()) {\n\t\tresult.location = index;\n\t\tresult.length = query.length;\n\t}\n\n\treturn result;\n}\n\n/**\n * A class for scoring and sorting a list of items against a query string.  Each\n * item receives a floating point score between `0` and `1`.\n */\nclass QuickScore {\n\t/**\n\t * @memberOf QuickScore.prototype\n\t * @member {Array<object>} items  The array of items to search, which\n\t * should only be modified via the [setItems()]{@link QuickScore#setItems}\n\t * method.\n\t * @readonly\n\t */\n\n\t/**\n\t * @memberOf QuickScore.prototype\n\t * @member {Array<ItemKey>} keys  The keys to search on each item, which\n\t * should only be modified via the [setItems()]{@link QuickScore#setKeys}\n\t * method.\n\t * @readonly\n\t */\n\n\t/**\n\t * @param {Array<string|object>} [items]  The list of items to score.  If\n\t * the list is not a flat array of strings, a `keys` array must be supplied\n\t * via the second parameter.  QuickScore makes a shallow copy of the `items`\n\t * array, so changes to it won't have any affect, but changes to the objects\n\t * referenced by the array need to be passed to the instance by a call to\n\t * its [setItems()]{@link QuickScore#setItems} method.\n\t *\n\t * @param {Array<ItemKey>|Options} [options]  If the `items` parameter\n\t * is an array of flat strings, the `options` parameter can be left out.  If\n\t * it is a list of objects containing keys that should be scored, the\n\t * `options` parameter must either be an array of key names or an object\n\t * containing a `keys` property.\n\t *\n\t * @param {Array<ItemKey>} [options.keys]  In the simplest case, an array of\n\t * key names to score on the objects in the `items` array.\n\t *\n\t * The key names can point to a nested key by passing either a dot-delimited\n\t * string or an array of sub-keys that specify the path to the value.  So a\n\t * key `name` of `\"foo.bar\"` would evaluate to `\"baz\"` given an object like\n\t * `{ foo: { bar: \"baz\" } }`.  Alternatively, that path could be passed as\n\t * an array, like `[\"foo\", \"bar\"]`.  In either case, if this sub-key's match\n\t * produces the highest score for an item in the search results, its\n\t * `scoreKey` name will be `\"foo.bar\"`.\n\t *\n\t * If your items have keys that contain periods, e.g., `\"first.name\"`, but\n\t * you don't want these names to be treated as paths to nested keys, simply\n\t * wrap the name in an array, like `{ keys: [\"ssn\", [\"first.name\"],\n\t * [\"last.name\"]] }`.\n\t *\n\t * Instead of a string or string array, an item in `keys` can also be passed\n\t * as a `{name, scorer}` object, which lets you specify a different scoring\n\t * function for each key.  The scoring function should behave as described\n\t * next.\n\t *\n\t * @param {string} [options.sortKey=options.keys[0]]  An optional key name\n\t * that will be used to sort items with identical scores.  Defaults to the\n\t * name of the first item in the `keys` parameter.  If `sortKey` points to\n\t * a nested key, use a dot-delimited string instead of an array to specify\n\t * the path.\n\t *\n\t * @param {number} [options.minimumScore=0]  An optional value that\n\t * specifies the minimum score an item must have to appear in the results\n\t * returned from [search()]{@link QuickScore#search}.  Defaults to `0`,\n\t * so items that don't match the full `query` will not be returned.  This\n\t * value is ignored if the `query` is empty or undefined, in which case all\n\t * items are returned, sorted alphabetically and case-insensitively on the\n\t * `sortKey`, if any.\n\t *\n\t * @param {TransformStringFunction} [options.transformString]  An optional\n\t * function that takes a `string` parameter and returns a transformed\n\t * version of that string.  This function will be called on each of the\n\t * searchable keys in the `items` array as well as on the `query`\n\t * parameter to the `search()` method.  The default function calls\n\t * `toLocaleLowerCase()` on each string, for a case-insensitive search.  The\n\t * result of this function is cached for each searchable key on each item.\n\t *\n\t * You can pass a function here to do other kinds of preprocessing, such as\n\t * removing diacritics from all the strings or converting Chinese characters\n\t * to pinyin.  For example, you could use the\n\t * [`latinize`](https://www.npmjs.com/package/latinize) npm package to\n\t * convert characters with diacritics to the base character so that your\n\t * users can type an unaccented character in the query while still matching\n\t * items that have accents or diacritics.  Pass in an `options` object like\n\t * this to use a custom `transformString()` function:\n\t * `{ transformString: s => latinize(s.toLocaleLowerCase()) }`\n\t *\n\t * @param {ScorerFunction} [options.scorer]  An optional function that takes\n\t * `string` and `query` parameters and returns a floating point number\n\t * between 0 and 1 that represents how well the `query` matches the\n\t * `string`.  It defaults to the [quickScore()]{@link quickScore} function\n\t * in this library.\n\t *\n\t * If the function gets a third `matches` parameter, it should fill the\n\t * passed-in array with indexes corresponding to where the query\n\t * matches the string, as described in the [search()]{@link QuickScore#search}\n\t * method.\n\t *\n\t * @param {Config} [options.config]  An optional object that is passed to\n\t * the scorer function to further customize its behavior.  If the\n\t * `scorer` function has a `createConfig()` method on it, the `QuickScore`\n\t * instance will call that with the `config` value and store the result.\n\t * This can be used to extend the `config` parameter with default values.\n\t */\n\tconstructor(\n\t\titems = [],\n\t\toptions = {})\n\t{\n\t\tconst {\n\t\t\tscorer = quickScore,\n\t\t\ttransformString = toLocaleLowerCase,\n\t\t\tkeys = [],\n\t\t\tsortKey = \"\",\n\t\t\tminimumScore = 0,\n\t\t\tconfig\n\t\t} = Array.isArray(options)\n\t\t\t? { keys: options }\n\t\t\t: options;\n\n\t\tthis.scorer = scorer;\n\t\tthis.minimumScore = minimumScore;\n\t\tthis.config = config;\n\t\tthis.transformStringFunc = transformString;\n\n\t\tif (typeof scorer.createConfig === \"function\") {\n\t\t\t\t// let the scorer fill out the config with default values\n\t\t\tthis.config = scorer.createConfig(config);\n\t\t}\n\n\t\tthis.setKeys(keys, sortKey);\n\t\tthis.setItems(items);\n\n\t\t\t// the scoring function needs access to this.sortKey\n\t\tthis.compareScoredStrings = this.compareScoredStrings.bind(this);\n\t}\n\n\n\t/**\n\t * Scores the instance's items against the `query` and sorts them from\n\t * highest to lowest.\n\t *\n\t * @param {string} query  The string to score each item against.  The\n\t * instance's `transformString()` function is called on this string before\n\t * it's matched against each item.\n\t *\n\t * @returns {Array<ScoredString|ScoredObject>}  When the instance's `items`\n\t * are flat strings, an array of [`ScoredString`]{@link ScoredString}\n\t * objects containing the following properties is returned:\n\t *\n\t * - `item`: the string that was scored\n\t * - `score`: the floating point score of the string for the current query\n\t * - `matches`: an array of arrays that specify the character ranges\n\t *   where the query matched the string\n\t *\n\t * When the `items` are objects, an array of [`ScoredObject`]{@link ScoredObject}\n\t * results is returned:\n\t *\n\t * - `item`: the object that was scored\n\t * - `score`: the highest score from among the individual key scores\n\t * - `scoreKey`: the name of the key with the highest score, which will be\n\t *   an empty string if they're all zero\n\t * - `scoreValue`: the value of the key with the highest score, which makes\n\t *   it easier to access if it's a nested string\n\t * - `scores`: a hash of the individual scores for each key\n\t * - `matches`: a hash of arrays that specify the character ranges of the\n\t *   query match for each key\n\t *\n\t * The results array is sorted high to low on each item's score.  Items with\n\t * identical scores are sorted alphabetically and case-insensitively on the\n\t * `sortKey` option.  Items with scores that are <= the `minimumScore` option\n\t * (defaults to `0`) are not returned, unless the `query` is falsy, in which\n\t * case all of the items are returned, sorted alphabetically.\n\t *\n\t * The start and end indices in each [`RangeTuple`]{@link RangeTuple} in the\n\t * `matches` array can be used as parameters to the `substring()` method to\n\t * extract the characters from each string that match the query.  This can\n\t * then be used to format the matching characters with a different color or\n\t * style.\n\t *\n\t * Each `ScoredObject` item also has a `_` property, which caches transformed\n\t * versions of the item's strings, and might contain additional internal\n\t * metadata in the future.  It can be ignored.\n\t */\n\tsearch(\n\t\tquery)\n\t{\n\t\tconst results = [];\n\t\tconst {items, transformedItems, keys: sharedKeys, config} = this;\n\t\t\t// if the query is empty, we want to return all items, so make the\n\t\t\t// minimum score less than 0\n\t\tconst minScore = query ? this.minimumScore : -1;\n\t\tconst transformedQuery = this.transformString(query);\n\t\tconst itemCount = items.length;\n\t\tconst sharedKeyCount = sharedKeys.length;\n\n\t\tif (typeof items[0] === \"string\") {\n\t\t\t\t// items is an array of strings\n\t\t\tfor (let i = 0; i < itemCount; i++) {\n\t\t\t\tconst item = items[i];\n\t\t\t\tconst transformedItem = transformedItems[i];\n\t\t\t\tconst matches = [];\n\t\t\t\tconst score = this.scorer(item, query, matches, transformedItem,\n\t\t\t\t\ttransformedQuery, config);\n\n\t\t\t\tif (score > minScore) {\n\t\t\t\t\tresults.push({\n\t\t\t\t\t\titem,\n\t\t\t\t\t\tscore,\n\t\t\t\t\t\tmatches,\n\t\t\t\t\t\t_: transformedItem\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < itemCount; i++) {\n\t\t\t\tconst item = items[i];\n\t\t\t\tconst transformedItem = transformedItems[i];\n\t\t\t\tconst result = {\n\t\t\t\t\titem,\n\t\t\t\t\tscore: 0,\n\t\t\t\t\tscoreKey: \"\",\n\t\t\t\t\tscoreValue: \"\",\n\t\t\t\t\tscores: {},\n\t\t\t\t\tmatches: {},\n\t\t\t\t\t_: transformedItem\n\t\t\t\t};\n\t\t\t\t\t// if an empty keys array was passed into the constructor,\n\t\t\t\t\t// score all of the non-empty string keys on the object\n\t\t\t\tconst keys = sharedKeyCount ? sharedKeys : Object.keys(transformedItem);\n\t\t\t\tconst keyCount = keys.length;\n\t\t\t\tlet highScore = 0;\n\t\t\t\tlet scoreKey = \"\";\n\t\t\t\tlet scoreValue = \"\";\n\n\t\t\t\t\t// find the highest score for each keyed string on this item\n\t\t\t\tfor (let j = 0; j < keyCount; j++) {\n\t\t\t\t\tconst key = keys[j];\n\t\t\t\t\t\t// use the key as the name if it's just a string, and\n\t\t\t\t\t\t// default to the instance's scorer function\n\t\t\t\t\tconst {name = key, scorer = this.scorer} = key;\n\t\t\t\t\tconst transformedString = transformedItem[name];\n\n\t\t\t\t\t\t// setItems() checks for non-strings and empty strings\n\t\t\t\t\t\t// when creating the transformed objects, so if the key\n\t\t\t\t\t\t// doesn't exist there, we can skip the processing\n\t\t\t\t\t\t// below for this key in this item\n\t\t\t\t\tif (transformedString) {\n\t\t\t\t\t\tconst string = this.getItemString(item, key);\n\t\t\t\t\t\tconst matches = [];\n\t\t\t\t\t\tconst newScore = scorer(string, query, matches,\n\t\t\t\t\t\t\ttransformedString, transformedQuery, config);\n\n\t\t\t\t\t\tresult.scores[name] = newScore;\n\t\t\t\t\t\tresult.matches[name] = matches;\n\n\t\t\t\t\t\tif (newScore > highScore) {\n\t\t\t\t\t\t\thighScore = newScore;\n\t\t\t\t\t\t\tscoreKey = name;\n\t\t\t\t\t\t\tscoreValue = string;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (highScore > minScore) {\n\t\t\t\t\tresult.score = highScore;\n\t\t\t\t\tresult.scoreKey = scoreKey;\n\t\t\t\t\tresult.scoreValue = scoreValue;\n\t\t\t\t\tresults.push(result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tresults.sort(this.compareScoredStrings);\n\n\t\treturn results;\n\t}\n\n\n\t/**\n\t * Sets the `keys` configuration.  `setItems()` must be called after\n\t * changing the keys so that the items' transformed strings get cached.\n\t *\n\t * @param {Array<ItemKey>} keys  List of keys to score, as either strings\n\t * or `{name, scorer}` objects.\n\t *\n\t * @param {string} [sortKey=keys[0]]  Name of key on which to sort\n\t * identically scored items.  Defaults to the first `keys` item.\n\t */\n\tsetKeys(\n\t\tkeys,\n\t\tsortKey)\n\t{\n\t\t\t// create a shallow copy of the keys array so that changes to its\n\t\t\t// order outside of this instance won't affect searching\n\t\tthis.keys = keys.slice();\n\t\tthis.sortKey = sortKey;\n\n\t\tif (this.keys.length) {\n\t\t\tconst {scorer} = this;\n\n\t\t\t\t// associate each key with the scorer function, if it isn't already\n\t\t\tthis.keys = this.keys.map(itemKey => {\n\t\t\t\t\t// items in the keys array should either be a string or\n\t\t\t\t\t// array specifying a key name, or a { name, scorer } object\n\t\t\t\tconst key = itemKey.length\n\t\t\t\t\t? { name: itemKey, scorer }\n\t\t\t\t\t: itemKey;\n\n\t\t\t\tif (Array.isArray(key.name)) {\n\t\t\t\t\tif (key.name.length > 1) {\n\t\t\t\t\t\tkey.path = key.name;\n\t\t\t\t\t\tkey.name = key.path.join(\".\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// this path consists of just one key name, which was\n\t\t\t\t\t\t\t// probably wrapped in an array because it contains\n\t\t\t\t\t\t\t// dots but isn't intended as a key path.  so don't\n\t\t\t\t\t\t\t// create a path array on this key, so that we're not\n\t\t\t\t\t\t\t// constantly calling reduce() to get this one key.\n\t\t\t\t\t\t[key.name] = key.name;\n\t\t\t\t\t}\n\t\t\t\t} else if (key.name.indexOf(\".\") > -1) {\n\t\t\t\t\tkey.path = key.name.split(\".\");\n\t\t\t\t}\n\n\t\t\t\treturn key;\n\t\t\t});\n\n\t\t\tthis.sortKey = this.sortKey || this.keys[0].name;\n\t\t}\n\t}\n\n\n\t/**\n\t * Sets the `items` array and caches a transformed copy of all the item\n\t * strings specified by the `keys` parameter to the constructor, using the\n\t * `transformString` option (which defaults to `toLocaleLowerCase()`).\n\t *\n\t * @param {Array<string|object>} items  List of items to score.\n\t */\n\tsetItems(\n\t\titems)\n\t{\n\t\t\t// create a shallow copy of the items array so that changes to its\n\t\t\t// order outside of this instance won't affect searching\n\t\tconst itemArray = items.slice();\n\t\tconst itemCount = itemArray.length;\n\t\tconst transformedItems = [];\n\t\tconst sharedKeys = this.keys;\n\t\tconst sharedKeyCount = sharedKeys.length;\n\n\t\tif (typeof itemArray[0] === \"string\") {\n\t\t\tfor (let i = 0; i < itemCount; i++) {\n\t\t\t\ttransformedItems.push(this.transformString(itemArray[i]));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < itemCount; i++) {\n\t\t\t\tconst item = itemArray[i];\n\t\t\t\tconst transformedItem = {};\n\t\t\t\tconst keys = sharedKeyCount ? sharedKeys : Object.keys(item);\n\t\t\t\tconst keyCount = keys.length;\n\n\t\t\t\tfor (let j = 0; j < keyCount; j++) {\n\t\t\t\t\tconst key = keys[j];\n\t\t\t\t\tconst string = this.getItemString(item, key);\n\n\t\t\t\t\tif (string && typeof string === \"string\") {\n\t\t\t\t\t\ttransformedItem[key.name || key] =\n\t\t\t\t\t\t\tthis.transformString(string);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttransformedItems.push(transformedItem);\n\t\t\t}\n\t\t}\n\n\t\tthis.items = itemArray;\n\t\tthis.transformedItems = transformedItems;\n\t}\n\n\n\t/**\n\t * Gets an item's key, possibly at a nested path.\n\t *\n\t * @private\n\t * @param {object} item  An object with multiple string properties.\n\t * @param {object|string} key  A key object with\n\t * the name of the string to get from `item`, or a plain string when all\n\t * keys on an item are being matched.\n\t * @returns {string}\n\t */\n\tgetItemString(\n\t\titem,\n\t\tkey)\n\t{\n\t\tconst {name, path} = key;\n\n\t\tif (path) {\n\t\t\treturn path.reduce((value, prop) => value && value[prop], item);\n\t\t} else {\n\t\t\t\t// if this instance is scoring all the keys on each item, key\n\t\t\t\t// will just be a string, not a { name, scorer } object\n\t\t\treturn item[name || key];\n\t\t}\n\t}\n\n\n\t/**\n\t * Transforms a string into a canonical form for scoring.\n\t *\n\t * @private\n\t * @param {string} string  The string to transform.\n\t * @returns {string}\n\t */\n\ttransformString(\n\t\tstring)\n\t{\n\t\treturn this.transformStringFunc(string);\n\t}\n\n\n\t/**\n\t * Compares two items based on their scores, or on their `sortKey` if the\n\t * scores are identical.\n\t *\n\t * @private\n\t * @param {object} a  First item.\n\t * @param {object} b  Second item.\n\t * @returns {number}\n\t */\n\tcompareScoredStrings(\n\t\ta,\n\t\tb)\n\t{\n\t\t\t// use the transformed versions of the strings for sorting\n\t\tconst itemA = a._;\n\t\tconst itemB = b._;\n\t\tconst itemAString = typeof itemA === \"string\"\n\t\t\t? itemA\n\t\t\t: itemA[this.sortKey];\n\t\tconst itemBString = typeof itemB === \"string\"\n\t\t\t? itemB\n\t\t\t: itemB[this.sortKey];\n\n\t\tif (a.score === b.score) {\n\t\t\t\t// sort undefineds to the end of the array, as per the ES spec\n\t\t\tif (itemAString === undefined || itemBString === undefined) {\n\t\t\t\tif (itemAString === undefined && itemBString === undefined) {\n\t\t\t\t\treturn 0;\n\t\t\t\t} else if (itemAString === undefined) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t} else if (itemAString === itemBString) {\n\t\t\t\treturn 0;\n\t\t\t} else if (itemAString < itemBString) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn b.score - a.score;\n\t\t}\n\t}\n}\n\n\n/**\n * Default function for transforming each string to be searched.\n *\n * @private\n * @param {string} string  The string to transform.\n * @returns {string}  The transformed string.\n */\nfunction toLocaleLowerCase(\n\tstring)\n{\n\treturn string.toLocaleLowerCase();\n}\n\nexport { BaseConfig, DefaultConfig, QuickScore, QuicksilverConfig, Range, createConfig, quickScore };\n"],"names":["Range","constructor","location","length","max","value","isValid","toArray","toString","BaseConfigDefaults","wordSeparators","uppercaseLetters","uppercase","i","push","String","fromCharCode","charCodeA","join","ignoredScore","skippedScore","emptyQueryScore","maxIterations","Math","QSConfigDefaults","longStringLength","maxMatchStartPct","minMatchDensityPct","maxMatchDensityPct","beginningOfStringPct","Config","options","Object","assign","useSkipReduction","adjustRemainingScore","string","query","remainingScore","skippedSpecialChar","searchRange","remainingSearchRange","matchedRange","fullMatchedRange","QuickScoreConfig","len","isShortString","matchStartPercentage","matchRangeDiscount","matchStartDiscount","min","createConfig","DefaultConfig","quickScore","matches","transformedString","toLocaleLowerCase","transformedQuery","config","stringRange","iterations","calcScore","queryRange","initialMatchesLength","querySubstring","substring","getRangeOfSubstring","index","indexOf","result","remainingQueryRange","score","j","QuickScore","items","scorer","transformString","keys","sortKey","minimumScore","Array","isArray","transformStringFunc","setKeys","setItems","compareScoredStrings","bind","search","results","transformedItems","sharedKeys","minScore","itemCount","sharedKeyCount","item","transformedItem","_","scoreKey","scoreValue","scores","keyCount","highScore","key","name","getItemString","newScore","sort","slice","map","itemKey","path","split","itemArray","reduce","prop","a","b","itemA","itemB","itemAString","itemBString","undefined"],"sourceRoot":""}